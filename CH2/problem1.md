
**레퍼런스는 변수의 별명과 같다. 대부분 메모리를 차지하지 않는다.**
# 1. 레퍼런스가 메모리 상에 반드시 존재해야 하는 경우? 
**주의 : 개인의 생각입니다 :)**
* 배열의 각 원소 같이 주소값이 존재하여 메모리 상에 원소가 존재하는 경우, 레퍼런스의 메모리를 차지하지 않는 다는 점에서 모순된다. 따라서 레퍼런스들의 배열(원소가 레퍼런스)은 불가능하다.
* 지역변수 같이 레퍼런스 된 변수가 사라진다면, 메모리 상에 레퍼런스가 존재해야 될 것 같긴하다. 하지만 지역변수는 레퍼런스 될 수 없다. 
* 추론해보자면, 레퍼런스 대상 변수가 지역변수가 아니며, 메모리가 사라지는 변수일 것 같다. 기존의 malloc을 하고 free를 통해 메모리가 해제된 변수는 레퍼런스의 메모리가 필요하지 않을까 생각한다.

**씹씨플 댓글**
* 함수의 매개변수로 참조자를 받을 때 주소를 전달하기 위해 메모리가 사용된다.
    void func1(int& ref) {
        ...
    } 

    int main() {
        int a=10;
        func1(a);
    }
* **메모리가 스코프 밖에서 사용된다면 메모리에 존재한다.(?)**
* 호출 스택이 달라질 때, 해당 메모리에 접근하기 위해 주소가 필요하다. 주소 메모리 공간이 필요하다.
* 레퍼런스를 인자로 넘기는 경우, 해당 함수에서 지역변수가 되어야한다. 레퍼런스 대상 변수의 주소값을 함수의 지역변수로 넘기는 일이 일어난다면, 메모리를 점유할 것 같다. **(대상 변수의 주소값 메모리)**
* 리턴값을 상수(const) 레퍼런스로 받는 경우, 상수 레퍼런스는 상수든 리터럴이든 가리키는 대상이 있어야 할텐데 없으니, 함수 내의 변수나 리터럴의 주소값을 가지는 식으로 메모리에 존재할 것 같다. **(상수 레퍼런스의 메모리)**
# 2. 레퍼런스가 메모리 상에 존재할 필요가 없는 경우?
**주의 : 개인의 생각입니다 :)**
* 레퍼런스가 단순히 변수의 별명 역할을 하고, 레퍼런스된 변수가 계속 존재한다면 메모리 상에 존재하지 않아도 된다. **일반적으로 존재하지 않는다.**

**씹씨플 댓글**
* 호출 스택이 같을 때, 바로 접근하며 따로 주소 메모리 공간이 불필요하다.